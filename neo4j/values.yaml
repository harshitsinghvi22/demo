# Default values for Neo4j.
# This is a YAML-formatted file.

neo4j:
  # If password is not set or empty a random password will be generated during installation
  password: ""
  edition: "community"
  # set edition: "enterprise" to use Neo4j Enterprise Edition
  #
  # In order to use Neo4j Enterprise Edition you must have a Neo4j license agreement.
  #
  # More information is also available at: https://neo4j.com/licensing/
  # Email inquiries can be directed to: licensing@neo4j.com
  #
  # Set acceptLicenseAgreement: "yes" to confirm that you have a Neo4j license agreement.
  acceptLicenseAgreement: "no"
  #
  # set offlineMaintenanceModeEnabled: true to restart the StatefulSet without the Neo4j process running
  # this can be used to perform tasks that cannot be performed when Neo4j is running such as `neo4j-admin dump`
  offlineMaintenanceModeEnabled: false


# Additional volumes for Neo4j
volumes:
  # REQUIRED: specify a volume to use for data
  data:
    # Valid values are share|selector|defaultStorageClass|volume|volumeClaimTemplate|dynamic
    mode: "selector"

    # Only used if mode is set to "selector"
    # Will attach to existing volumes that match the selector
    selector:
      storageClassName: "manual"
      accessModes:
        - ReadWriteOnce
      requests:
        storage: 100Gi
      # A helm template to generate a label selector to match existing volumes n.b. both storageClassName and label selector must match existing volumes
      selectorTemplate:
        matchLabels:
          app: "{{ .Values.neo4j.name }}"
          helm.neo4j.com/volume-role: "data"

    # Only used if mode is set to "defaultStorageClass"
    # Dynamic provisioning using the default storageClass
    defaultStorageClass:
      accessModes:
        - ReadWriteOnce
      requests:
        storage: 10Gi

    # Only used if mode is set to "dynamic"
    # Dynamic provisioning using the provided storageClass
    dynamic:
      accessModes:
        - ReadWriteOnce
      storageClassName: "neo4j"
      requests:
        storage: 1Ti

    # Only used if mode is set to "volume"
    # Provide an explicit volume to use
    volume:
      # If set an init container (running as root) will be added that runs:
      #   `chown -R <securityContext.fsUser>:<securityContext.fsGroup>` AND `chmod -R g+rwx`
      # on the volume. This is useful for some filesystems (e.g. NFS) where Kubernetes fsUser or fsGroup settings are not respected
      setOwnerAndGroupWritableFilePermissions: false

    # Only used if mode is set to "volumeClaimTemplate"
    # Provide an explicit volumeClaimTemplate to use
    volumeClaimTemplate: {}

  # provide a volume to use for backups
  # n.b. backups will be written to /backups on the volume
  # any of the volume modes shown above for data can be used for backups
  backups:
    mode: "share" # share an existing volume (e.g. the data volume)
    share:
      name: "data"

  # provide a volume to use for logs
  # n.b. logs will be written to /logs/$(POD_NAME) on the volume
  # any of the volume modes shown above for data can be used for logs
  logs:
    mode: "share" # share an existing volume (e.g. the data volume)
    share:
      name: "data"

  # provide a volume to use for metrics
  # n.b. metrics will be written to /metrics/$(POD_NAME) on the volume
  # any of the volume modes shown above for data can be used for metrics
  metrics:
    mode: "share" # share an existing volume (e.g. the data volume)
    share:
      name: "data"

  # provide a volume to use for import storage
  # n.b. import will be mounted to /import on the underlying volume
  # any of the volume modes shown above for data can be used for import
  import:
    mode: "share" # share an existing volume (e.g. the data volume)
    share:
      name: "data"

  # provide a volume to use for licenses
  # n.b. licenses will be mounted to /licenses on the underlying volume
  # any of the volume modes shown above for data can be used for licenses
  licenses:
    mode: "share" # share an existing volume (e.g. the data volume)
    share:
      name: "data"

# Neo4j Configuration

# Neo4j configuration (yaml format)
config:
  dbms.config.strict_validation: "true"

# Neo4j configuration (text format)
configImport: |
  # neo4j.conf key=value properties file contents can be included here.
  # multi-line text must be indented correctly.


# securityContext defines privilege and access control settings for a Pod
# or Container. Making sure that we dont run Neo4j as root user.
securityContext:
  runAsNonRoot: true
  runAsUser: 7474
  runAsGroup: 7474
  fsGroup: 7474
  fsGroupChangePolicy: "Always"

# Readiness probes will send a kill signal to the container if
# it fails enough times.  It's therefore very important
# that initialDelaySeconds give the cluster time to form, because
# if readiness probes start immediately after container start,
# they may end up not forming quickly enough and getting killed.
readinessProbe:
  failureThreshold: 2
  timeoutSeconds: 2
  periodSeconds: 1

# Liveness probes are set to know when to restart a container
livenessProbe:
  failureThreshold: 30
  timeoutSeconds: 2
  periodSeconds: 20

# Startup probes are used to know when a container application has started.
# If such a probe is configured, it disables liveness and readiness checks until it succeeds
startupProbe:
  failureThreshold: 2000
  periodSeconds: 25

# top level setting called ssl to match the "ssl" from "dbms.ssl.policy"
ssl:
  # setting per "connector" matching neo4j config
  bolt:
    privateKey:
      secretName:  # we set up the template to grab `private.key` from this secret
      subPath:  # we specify the privateKey value name to get from the secret
    publicCertificate:
      secretName:  # we set up the template to grab `public.crt` from this secret
      subPath:  # we specify the publicCertificate value name to get from the secret
    trustedCerts:
      sources: [ ] # a sources array for a projected volume - this allows someone to (relatively) easily mount multiple public certs from multiple secrets for example.
    revokedCerts:
      sources: [ ]  # a sources array for a projected volume
  https:
    privateKey:
      secretName:
      subPath:
    publicCertificate:
      secretName:
      subPath:
    trustedCerts:
      sources: [ ]
    revokedCerts:
      sources: [ ]

# A ClusterIP service for Neo4j driver applications and Neo4j Browser
neo4jService:
  # Annotations for the Neo4j service
  annotations: { }

# A headless service (DNS only) for cluster admin and ops tasks
adminService:
  # Annotations for the admin service
  annotations: { }
  # Neo4j ports to include in admin service
  ports:
    # Ports for Neo4j Cluster
    cluster:
      enabled: false
    # Ports for Neo4j metrics
    metrics:
      graphite:
        enabled: true
      prometheus:
        enabled: true
      jmx:
        enabled: false # jmx is disabled because it's not secure to enable it unless jmx authentication is configured in neo4j config

externalService:
  # Annotations for the external service
  annotations: { }

  # A reserved/static IP that you want the LoadBalancer to use (usually optional, depending on the load balancer implmentation)
  loadBalancerIP: NULL

  # Neo4j ports to include in external service
  ports:
    http:
      enabled: true #Set this to true to expose HTTP externally
    https:
      enabled: true #Set this to true to expose HTTPS externally
    bolt:
      enabled: true #Set this to true to expose BOLT externally
    backup:
      enabled: false #Set this to true to expose backup port externally (n.b. this could have security implications. Backup is not authenticated by default)

# Kubernetes cluster domain suffix
clusterDomain: "cluster.local"

# Override image settings in Neo4j pod
image:
  imagePullPolicy: IfNotPresent

podAntiAffinity: true

# initContainers for the Neo4j pod
initContainers: []

# log the neo4j user password set during `helm install`
logInitialPassword: true
