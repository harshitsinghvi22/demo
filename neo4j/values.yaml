# Default values for Neo4j.
# This is a YAML-formatted file.
# Declare name/value pairs to be passed into your templates.
# name: value

name: neo4j-db

neo4j:
  # If not set or empty a random password will be generated
  password: ""

# The volumeClaimTemplates will provide stable storage
volumeClaimTemplates:
  # Using "manual" storage class prevents automatic provisioning and only makes use of manually defined PVCs
  storageClassName: "manual"
  accessModes:
    - ReadWriteOnce
  request: 1Ti

# Specs for the Neo4j docker image
image:
  imagePullPolicy: IfNotPresent
  customImage: "neo4j:4.3-enterprise"

### Neo4j Configuration

# Neo4j configuration (yaml format)
config:
  dbms.config.strict_validation: "true"

# Neo4j configuration (text format)
configImport: |
  # neo4j.conf key=value properties file contents can be included here.
  # multi-line text must be indented correctly.


# securityContext defines privilege and access control settings for a Pod
# or Container. Making sure that we dont run Neo4j as root user.
securityContext:
  runAsNonRoot: true
  runAsUser: 7474
  runAsGroup: 7474
  fsGroup: 7474


# Readiness probes will send a kill signal to the container if
# it fails enough times.  It's therefore very important
# that initialDelaySeconds give the cluster time to form, because
# if readiness probes start immediately after container start,
# they may end up not forming quickly enough and getting killed.
readinessProbe:
  failureThreshold: 2
  timeoutSeconds: 2
  periodSeconds: 1

# Liveness probes are set to know when to restart a container
livenessProbe:
  failureThreshold: 30
  timeoutSeconds: 2
  periodSeconds: 20

# Startup probes are used to know when a container application has started.
# If such a probe is configured, it disables liveness and readiness checks until it succeeds
startupProbe:
  failureThreshold: 2000
  periodSeconds: 25

# top level setting called ssl to match the "ssl" from "dbms.ssl.policy"
ssl:
  # setting per "connector" matching neo4j config
  bolt:
    privateKey:
      secretName:  # we set up the template to grab `private.key` from this secret
    publicCertificate:
      secretName:  # we set up the template to grab `public.crt` from this secret
    trustedCerts:
      sources: [ ] # a sources array for a projected volume - this allows someone to (relatively) easily mount multiple public certs from multiple secrets for example.
    revokedCerts:
      sources: [ ]  # a sources array for a projected volume
  https:
    privateKey:
      secretName:
    publicCertificate:
      secretName:
    trustedCerts:
      sources: [ ]
    revokedCerts:
      sources: [ ]

# A headless service that ensures the statefulset gets a dns entry
dnsService:
  # Annotations for the dns service
  annotations: { }

# A headless service
internalService:
  # Annotations for the internal service
  annotations: { }
  # Neo4j ports to include in k8s internal service
  ports:
    # Ports for Neo4j Cluster
    cluster:
      enabled: false
    # Ports for Neo4j metrics
    metrics:
      graphite:
        enabled: false
      prometheus:
        enabled: false
      jmx:
        enabled: false

externalService:
  # Annotations for the external service
  annotations: { }
  # Neo4j ports to include in external service
  ports:
    http:
      enabled: true #Set this to true to expose HTTP externally
    https:
      enabled: true #Set this to true to expose HTTPS externally
    bolt:
      enabled: true #Set this to true to expose BOLT externally
    backup:
      enabled: false #Set this to true to expose backup port externally (n.b. this could have security implications. Backup is not authenticated by default)

clusterDomain: "cluster.local"
