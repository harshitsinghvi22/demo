{{- $clusterEnabled := or ( index .Values.config "dbms.mode" | default "" | regexMatch "(?i)core|replica" ) ( index .Values.config "dbms.clustering.enable" | default "" | regexMatch "(?i)true|yes" ) }}
# Neo4j config values that are required for neo4j to work correctly in Kubernetes, these are not overridden by user-provided values
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-k8s-config
  namespace: {{ .Release.Namespace }}
data:
  dbms.default_listen_address: "0.0.0.0"
  dbms.ssl.policy.bolt.enabled: "{{ if .Values.ssl.bolt.privateKey.secretName }}true{{ else }}false{{ end }}"
  dbms.ssl.policy.https.enabled: "{{ if .Values.ssl.https.privateKey.secretName }}true{{ else }}false{{ end }}"
  dbms.connector.bolt.tls_level: "{{ if .Values.ssl.https.privateKey.secretName }}REQUIRED{{ else }}DISABLED{{ end }}"
  dbms.connector.https.enabled: "{{ if .Values.ssl.https.privateKey.secretName }}true{{ else }}false{{ end }}"
---
{{- $confFile := .Files.Get "neo4j.conf" -}}
{{- $configImport := .Values.configImport -}}
# User-provided Neo4j config values
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-user-config
  namespace: {{ .Release.Namespace }}
data:
  {{- /* imported config first */}}
    {{- if regexMatch "dbms\\.jvm\\.additional" .Values.configImport }}
      {{- fail "dbms.jvm.additional properties are not currently supported in values.configImport" }}
    {{- end }}
  {{- include "neo4j.configYaml" $configImport | nindent 2 }}

  {{- /* then explicit config - throw an error if it contains jvm additional */}}
  {{- with toYaml .Values.config }}
    {{- if regexMatch "dbms\\.jvm\\.additional" . }}
      {{- fail "dbms.jvm.additional properties are not currently supported in values.config" }}
    {{- else }}
      {{- nindent 2 . }}
    {{- end }}
  {{- end }}

  {{- /* then default jvm config */}}
  {{- include "neo4j.configJvmAdditionalYaml" $confFile | nindent 2 }}
---
# Default Neo4j config values, these are overridden by user-provided values in {{ .Release.Name }}-user-config
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-default-config
  namespace: {{ .Release.Namespace }}
data:
  # Helm defaults
  dbms.mode: "{{ index .Values.config "dbms.mode" | default "SINGLE"}}"

  # If we set default advertised address it over-rides the bolt address used to populate the browser in a really annoying way
  # dbms.default_advertised_address: "$(bash -c 'echo ${SERVICE_DOMAIN}')"

  # Other
  dbms.config.strict_validation: "true"

  {{- if $clusterEnabled }}
  # Clustering
  causal_clustering.discovery_type: K8S
  causal_clustering.kubernetes.service_port_name: "tcp-discovery"
  causal_clustering.kubernetes.label_selector: "app={{ template "neo4j.appName" . }},helm.neo4j.com/service=admin,neo4j.com/dbms.mode=CORE"

  # Because "if we set default advertised address it over-rides the bolt address used to populate the browser in a really annoying way" we have to set the
  # advertised address for each cluster service individually instead
  causal_clustering.discovery_advertised_address: "$(bash -c 'echo ${SERVICE_ADMIN}')"
  causal_clustering.raft_advertised_address: "$(bash -c 'echo ${SERVICE_ADMIN}')"
  causal_clustering.transaction_advertised_address: "$(bash -c 'echo ${SERVICE_ADMIN}')"
  dbms.routing.advertised_address: "$(bash -c 'echo ${SERVICE_ADMIN}')"
  {{- end }}

  # Logging
  {{- /* TODO: Figure out a different way to handle logs. I dislike remapping the log location to the data directory like this */}}
  dbms.directories.logs: "/data/logs"

  # Neo4j defaults
  {{- /* TODO: figure out how to use lookup to detect if there is an existing default configMap and require user to explicitly force overwrite */}}
  {{- include "neo4j.configYaml" $confFile | nindent 2 }}
